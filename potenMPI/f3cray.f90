       subroutine f3cray

! c       Russ's Multigrid Code to Solve For Linear Force Free Fields
! c       a la Finn et al (in Ap J). Linear elliptic equation in the
! c       vector potential A(x,y,z). V-cycle, with full weighting for
! c       restriction, and tri-linear interpolation for prolongation.
! c
! c       This version slightly different from finn.f in that the
! c       order of the solve in RELAX is neater here.
! c
! c       Basic grid sizes etc entered via DATA.IN, and results written
! c       to AX/AY/AZ.OUTPT to be post-processed by process.f, resulting
! c       in the actual magnetic field data in BX/BY/BZOUT. Some scaling
! c       factors for the source BZ on the base are to be found in
! c       FUNCTION AXSET. Relevant
! c       idl .pro routines can then detail the field structure etc.
! c
! c       This version reads in AX and AY on the base from data sets
! c       generated by BZIDCG.F solving a more general base condition
! c       for the potentials.
! c
! c       Implement an SOR version of Russ's basic Gauss-Seidel routine.
! c       Relaxation parameter is OM (> or =1). Seem to get a good
! c       speed up wrt to the basic GS routine!!!!!!!!!!!!!!!!!!!!!!!!!
! c
! c       GJR Dec 95
! c
! c       VERSION FOR RUNNING ON THE CRAY J90.
! c
! c----------------------------------------------------------------------
! c
      use duncan 
      use cdata
      IMPLICIT NONE
      INTEGER NMAX,NMAX3,NMAX7
      !PARAMETER (NMAX=NX0,NMAX3=NMAX**3,NMAX7=NMAX3/6)
     
     
     double precision, allocatable :: rhsx(:),rhsy(:),rhsz(:)
     DOUBLE PRECISION, allocatable :: EPSX(:),EPSRHSX(:)
     DOUBLE PRECISION, allocatable :: EPSY(:),EPSRHSY(:)
     DOUBLE PRECISION, allocatable :: EPSZ(:),EPSRHSZ(:)
     DOUBLE PRECISION,allocatable :: RES(:)
     DOUBLE PRECISION,allocatable :: EPSRES(:)
     
     
     ! DOUBLE PRECISION AX(NMAX3),AY(NMAX3),AZ(NMAX3)
    !  DOUBLE PRECISION RHSX(NMAX3),RHSY(NMAX3),RHSZ(NMAX3)
    !  DOUBLE PRECISION EPSX(NMAX7),EPSRHSX(NMAX7)
    !  DOUBLE PRECISION EPSY(NMAX7),EPSRHSY(NMAX7)
    !  DOUBLE PRECISION EPSZ(NMAX7),EPSRHSZ(NMAX7)
! C23456789012345678901234567890123456789012345678901234567890123456789012
     ! DOUBLE PRECISION RES(NMAX3)
      !DOUBLE PRECISION EPSRES(NMAX7)
      INTEGER INDEX(10),NX(10),NY(10),NZ(10),NPOINTS(10)
      INTEGER IDX,IDXM,ILEV!,ITS
      DOUBLE PRECISION WORK,ERRORX,ERRORY,ERRORZ,ERROR
     ! INTEGER NX0,NY0,NZ0,NLEV,MAXITS,I,ISTART
      INTEGER NY0,NZ0,I
      INTEGER NOUT
      !DOUBLE PRECISION H0,DELTA,WMAX
      DOUBLE PRECISION AXSET,AYSET,AZSET
     ! DOUBLE PRECISION ALPHA,OM
     ! COMMON/CONST/ ALPHA,H0,NX0
      !  COMMON/SORE/ OM
     ! common/duncan/AX,AY,AZ
      EXTERNAL AXSET,AYSET,AZSET
      
    
     
     
     
      
      
      REAL TIMEAR(2),DUM,DTIME
      
      
       NMAX=NX0
     NMAX3=NMAX**3
     NMAX7=NMAX3/6 
     
     
     allocate(RHSX(NMAX3),RHSY(NMAX3),RHSZ(NMAX3))
     allocate( EPSX(NMAX7),EPSRHSX(NMAX7))
     allocate(  EPSY(NMAX7),EPSRHSY(NMAX7))
     allocate(  EPSZ(NMAX7),EPSRHSZ(NMAX7))
     allocate(  RES(NMAX3))
     allocate(  EPSRES(NMAX7))
      
     !print*,'allocated f2cray'
      
      DUM = DTIME(TIMEAR)
      WORK=0
      ERROR=1.D30
      NOUT=9
      
      allocate(ax(nmax3),ay(nmax3),az(nmax3))
     ! print*,'allocated duncan'
      
! c
! c----------------- relaxation parameter
! c
! c       OM = 1.5
! c       read(5,*)OM
! c
! c---------------------------------------
! c
! c      OPEN(UNIT=3,FILE='CWORK.DAT',STATUS='NEW')
! !      OPEN(UNIT=3,FILE='CWORK.DAT')
    !  OPEN(UNIT=10,FILE='CDATA.IN',FORM='FORMATTED',STATUS='OLD')
! c  OPEN(UNIT=NOUT,FILE='fort.finn3',FORM='FORMATTED',STATUS='NEW')
! !      OPEN(UNIT=NOUT,FILE='fort.finn3',FORM='FORMATTED')
    !  READ(10,*) NX0,OM,H0,DELTA,NLEV,WMAX,MAXITS,ISTART,ALPHA
! *      print *,alpha
     ! CLOSE(10)
! c
      NY0 = NX0
      NZ0 = NX0
! c
!      WRITE(NOUT,*) NX0,NY0,NZ0,H0,DELTA,NLEV,WMAX,MAXITS,ISTART,ALPHA
      NX(NLEV)=NX0
      NY(NLEV)=NY0
      NZ(NLEV)=NZ0
      NPOINTS(NLEV)=NX(NLEV)*NY(NLEV)*NZ(NLEV)
      INDEX(NLEV)=1-NPOINTS(NLEV)
      DO ILEV=NLEV-1,1,-1
         NX(ILEV)=(NX(ILEV+1)-1)/2+1
         NY(ILEV)=(NY(ILEV+1)-1)/2+1
         NZ(ILEV)=(NZ(ILEV+1)-1)/2+1
         NPOINTS(ILEV)=NX(ILEV)*NY(ILEV)*NZ(ILEV)
         INDEX(ILEV)=INDEX(ILEV+1)+NPOINTS(ILEV+1)
      ENDDO
      CALL ZEROARR(NPOINTS(NLEV),RHSX(1))
      CALL ZEROARR(NPOINTS(NLEV),RHSY(1))
      CALL ZEROARR(NPOINTS(NLEV),RHSZ(1))
      IF(ISTART.NE.0) THEN
        OPEN(UNIT=2,FILE='AX.OUTPT',STATUS='OLD',FORM='UNFORMATTED')
        READ(2) (AX(I),I=1,NPOINTS(NLEV))
        CLOSE(2)
        OPEN(UNIT=2,FILE='AY.OUTPT',STATUS='OLD',FORM='UNFORMATTED')
        READ(2) (AY(I),I=1,NPOINTS(NLEV))
        CLOSE(2)
        OPEN(UNIT=2,FILE='AZ.OUTPT',STATUS='OLD',FORM='UNFORMATTED')
        READ(2) (AZ(I),I=1,NPOINTS(NLEV))
        CLOSE(2)
      ELSE
       ! print*,'pre-initialise'
        CALL INITIALISE(NX(NLEV),NY(NLEV),NZ(NLEV),H0,AX,AXSET)
        CALL INITIALISE(NX(NLEV),NY(NLEV),NZ(NLEV),H0,AY,AYSET)
        CALL INITIALISE(NX(NLEV),NY(NLEV),NZ(NLEV),H0,AZ,AZSET)
       ! print*,'post-initialise'
      ENDIF
! c      CALL BOUNDY(NX(NLEV),NY(NLEV),NZ(NLEV),H0,AX,AXSET)
! c      CALL BOUNDY(NX(NLEV),NY(NLEV),NZ(NLEV),H0,AY,AYSET)
! c      CALL BOUNDY(NX(NLEV),NY(NLEV),NZ(NLEV),H0,AZ,AZSET)
! C
! C
! C PUT STUFF BELOW HERE INTO SUBROUTINE?
! C
! C
     ! print*,'pre-initialas'
      CALL INITIALAS(NX(NLEV),NY(NLEV),NZ(NLEV),H0,AX,AY)
      CALL BASE(NX(NLEV),NY(NLEV),NZ(NLEV),RHSZ,AX,AY)
     ! print*,'post base'
! c      DO ITS=1,MAXITS
! C
! C
! c      CALL RESIDUALX(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,
! c     &               RHSX,RES,ERRORX)
! c      CALL RESIDUALY(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,
! c     &               RHSY,RES,ERRORY)
! c      CALL RESIDUALZ(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,
! c     &               RHSZ,RES,ERRORZ)
! c      ERROR=SQRT((ERRORX**2+ERRORY**2+ERRORZ**2)/3)
! c      WRITE(NOUT,*) 'A - LEVEL ',NLEV,' ERROR =',ERRORX,ERRORY,ERRORZ,ERROR
! 
! C
! C MAIN A LOOP
! C
      WORK=0.
10    CONTINUE
      DO ILEV=NLEV-1,1,-1
        CALL ZEROARR(NPOINTS(ILEV),EPSX(INDEX(ILEV)))
        CALL ZEROARR(NPOINTS(ILEV),EPSY(INDEX(ILEV)))
        CALL ZEROARR(NPOINTS(ILEV),EPSZ(INDEX(ILEV)))
      ENDDO

      ILEV=NLEV
     !print*,'pre relax'
      CALL RELAX(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,&
                          RHSX,RHSY,RHSZ)
     ! print*,'post-relax'
      WORK=WORK+1.
      CALL RESIDUALX(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,&
                    RHSX,RES,ERRORX)
      CALL RESTRICTC (NX(ILEV),NY(ILEV),NZ(ILEV),RES,&
                    NX(ILEV-1),NY(ILEV-1),NZ(ILEV-1),&
                    EPSRHSX(INDEX(ILEV-1)))
      CALL RESIDUALY(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,&
                    RHSY,RES,ERRORY)
      CALL RESTRICTC (NX(ILEV),NY(ILEV),NZ(ILEV),RES,&
                    NX(ILEV-1),NY(ILEV-1),NZ(ILEV-1),&
                    EPSRHSY(INDEX(ILEV-1)))
      CALL RESIDUALZ(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,&
                    RHSZ,RES,ERRORZ)
      CALL RESTRICTC (NX(ILEV),NY(ILEV),NZ(ILEV),RES,&
                    NX(ILEV-1),NY(ILEV-1),NZ(ILEV-1),&
                    EPSRHSZ(INDEX(ILEV-1)))
      ERROR=SQRT((ERRORX**2+ERRORY**2+ERRORZ**2)/3)
!      WRITE(NOUT,*) 'A - LEVEL ',ILEV,' ERROR =',ERRORX,ERRORY,ERRORZ
      DO ILEV=NLEV-1,2,-1
        IDX=INDEX(ILEV)
        IDXM=INDEX(ILEV-1)
! c        CALL RESIDUALX(NX(ILEV),NY(ILEV),NZ(ILEV),
! c     &              EPSX(IDX),EPSY(IDX),EPSZ(IDX),
! c     &              EPSRHSX(IDX),EPSRES(IDX),ERRORX)
! c        CALL RESIDUALY(NX(ILEV),NY(ILEV),NZ(ILEV),
! c     &              EPSX(IDX),EPSY(IDX),EPSZ(IDX),
! c     &              EPSRHSY(IDX),EPSRES(IDX),ERRORY)
! c        CALL RESIDUALZ(NX(ILEV),NY(ILEV),NZ(ILEV),
! c     &              EPSX(IDX),EPSY(IDX),EPSZ(IDX),
! c     &              EPSRHSZ(IDX),EPSRES(IDX),ERRORZ)
! c        ERROR=SQRT((ERRORX**2+ERRORY**2+ERRORZ**2)/3)
! c        WRITE(NOUT,*) 'A - LEVEL ',ILEV,' ERROR =',ERRORX,ERRORY,ERRORZ


        CALL RELAX(NX(ILEV),NY(ILEV),NZ(ILEV),&
         EPSX(IDX),EPSY(IDX),EPSZ(IDX),&
         EPSRHSX(IDX),EPSRHSY(IDX),EPSRHSZ(IDX))
        WORK=WORK+2.**(3*(ILEV-NLEV))
        CALL RESIDUALX(NX(ILEV),NY(ILEV),NZ(ILEV),&
                   EPSX(IDX),EPSY(IDX),EPSZ(IDX),&
                   EPSRHSX(IDX),EPSRES(IDX),ERRORX)
        CALL RESTRICTC (NX(ILEV),NY(ILEV),NZ(ILEV),EPSRES(IDX),&
                NX(ILEV-1),NY(ILEV-1),NZ(ILEV-1),EPSRHSX(IDXM))
        CALL RESIDUALY(NX(ILEV),NY(ILEV),NZ(ILEV),&
                  EPSX(IDX),EPSY(IDX),EPSZ(IDX),&
                   EPSRHSY(IDX),EPSRES(IDX),ERRORY)
        CALL RESTRICTC (NX(ILEV),NY(ILEV),NZ(ILEV),EPSRES(IDX),&
                NX(ILEV-1),NY(ILEV-1),NZ(ILEV-1),EPSRHSY(IDXM))
        CALL RESIDUALZ(NX(ILEV),NY(ILEV),NZ(ILEV),&
                   EPSX(IDX),EPSY(IDX),EPSZ(IDX),&
                   EPSRHSZ(IDX),EPSRES(IDX),ERRORZ)
        CALL RESTRICTC (NX(ILEV),NY(ILEV),NZ(ILEV),EPSRES(IDX),&
                NX(ILEV-1),NY(ILEV-1),NZ(ILEV-1),EPSRHSZ(IDXM))
        ERROR=SQRT((ERRORX**2+ERRORY**2+ERRORZ**2)/3)
! c        WRITE(NOUT,*) 'A - LEVEL ',ILEV,' ERROR =',ERRORX,ERRORY,ERRORZ


      ENDDO

      DO WHILE (ERROR.GT.DELTA.AND. WORK.LT.WMAX)
        ILEV=1
        IDX=INDEX(ILEV)
        CALL RELAX(NX(ILEV),NY(ILEV),NZ(ILEV),&
        EPSX(IDX),EPSY(IDX),EPSZ(IDX),&
         EPSRHSX(IDX),EPSRHSY(IDX),EPSRHSZ(IDX))
        CALL RESIDUALX(NX(ILEV),NY(ILEV),NZ(ILEV),&
                   EPSX(IDX),EPSY(IDX),EPSZ(IDX),&
                   EPSRHSX(IDX),EPSRES(IDX),ERRORX)
        CALL RESIDUALY(NX(ILEV),NY(ILEV),NZ(ILEV),&
                   EPSX(IDX),EPSY(IDX),EPSZ(IDX),&
                   EPSRHSY(IDX),EPSRES(IDX),ERRORY)
        CALL RESIDUALZ(NX(ILEV),NY(ILEV),NZ(ILEV),&
                   EPSX(IDX),EPSY(IDX),EPSZ(IDX),&
                   EPSRHSZ(IDX),EPSRES(IDX),ERRORZ)
        ERROR=SQRT((ERRORX**2+ERRORY**2+ERRORZ**2)/3)
! c        WRITE(NOUT,*) 'A - LEVEL ',ILEV,' ERROR =',ERRORX,ERRORY,ERRORZ
      ENDDO
! 
! !        WRITE(NOUT,*) '                    '
! !        WRITE(NOUT,*) 'ILEV=1 ERROR =',ERRORX,ERRORY,ERRORZ
! !        WRITE(NOUT,*) '                    '
! c       WRITE(6,*) '                    '
! c        WRITE(6,*) 'ILEV=1 ERROR =',ERRORX,ERRORY,ERRORZ
! c       WRITE(6,*) '                    '

      IF(ERROR.GT.DELTA)THEN
! !        WRITE(NOUT,*) 'FAILED TO CONVERGE ON ILEV=1'
! !        WRITE(NOUT,*) '                    '
! c       WRITE(6,*) 'FAILED TO CONVERGE ON ILEV=1'
! c       WRITE(6,*) '                    '
      ENDIF

      DO ILEV=2,NLEV-1
        IDX=INDEX(ILEV)
        IDXM=INDEX(ILEV-1)
        CALL INTADD (NX(ILEV),NY(ILEV),NZ(ILEV),EPSX(IDX),&
                NX(ILEV-1),NY(ILEV-1),NZ(ILEV-1),EPSX(IDXM))
        CALL INTADD (NX(ILEV),NY(ILEV),NZ(ILEV),EPSY(IDX),&
                NX(ILEV-1),NY(ILEV-1),NZ(ILEV-1),EPSY(IDXM))
        CALL INTADD (NX(ILEV),NY(ILEV),NZ(ILEV),EPSZ(IDX),&
                NX(ILEV-1),NY(ILEV-1),NZ(ILEV-1),EPSZ(IDXM))
! c        CALL RESIDUALX(NX(ILEV),NY(ILEV),NZ(ILEV),
! c     &              EPSX(IDX),EPSY(IDX),EPSZ(IDX),
! c     &              EPSRHSX(IDX),EPSRES(IDX),ERRORX)
! c        CALL RESIDUALY(NX(ILEV),NY(ILEV),NZ(ILEV),
! c     &              EPSX(IDX),EPSY(IDX),EPSZ(IDX),
! c     &              EPSRHSY(IDX),EPSRES(IDX),ERRORY)
! c        CALL RESIDUALZ(NX(ILEV),NY(ILEV),NZ(ILEV),
! c     &              EPSX(IDX),EPSY(IDX),EPSZ(IDX),
! c     &              EPSRHSZ(IDX),EPSRES(IDX),ERRORZ)
! c        ERROR=SQRT((ERRORX**2+ERRORY**2+ERRORZ**2)/3)
! c        WRITE(NOUT,*) 'A - LEVEL ',ILEV,' ERROR =',ERRORX,ERRORY,ERRORZ
        CALL RELAX(NX(ILEV),NY(ILEV),NZ(ILEV),&
         EPSX(IDX),EPSY(IDX),EPSZ(IDX),&
         EPSRHSX(IDX),EPSRHSY(IDX),EPSRHSZ(IDX))
        WORK=WORK+2.**(3*(ILEV-NLEV))
! c        CALL RESIDUALX(NX(ILEV),NY(ILEV),NZ(ILEV),
! c     &              EPSX(IDX),EPSY(IDX),EPSZ(IDX),
! c     &              EPSRHSX(IDX),EPSRES(IDX),ERRORX)
! c        CALL RESIDUALY(NX(ILEV),NY(ILEV),NZ(ILEV),
! c     &              EPSX(IDX),EPSY(IDX),EPSZ(IDX),
! c     &              EPSRHSY(IDX),EPSRES(IDX),ERRORY)
! c        CALL RESIDUALZ(NX(ILEV),NY(ILEV),NZ(ILEV),
! c     &              EPSX(IDX),EPSY(IDX),EPSZ(IDX),
! c     &              EPSRHSZ(IDX),EPSRES(IDX),ERRORZ)
! c        ERROR=SQRT((ERRORX**2+ERRORY**2+ERRORZ**2)/3)
! c        WRITE(NOUT,*) 'A - LEVEL ',ILEV,' ERROR =',ERRORX,ERRORY,ERRORZ

      ENDDO
      ILEV=NLEV
      IDXM=INDEX(ILEV-1)
      CALL INTADD (NX(ILEV),NY(ILEV),NZ(ILEV),AX,&
                  NX(ILEV-1),NY(ILEV-1),NZ(ILEV-1),EPSX(IDXM))
      CALL INTADD (NX(ILEV),NY(ILEV),NZ(ILEV),AY,&
                  NX(ILEV-1),NY(ILEV-1),NZ(ILEV-1),EPSY(IDXM))
      CALL INTADD (NX(ILEV),NY(ILEV),NZ(ILEV),AZ,&
                  NX(ILEV-1),NY(ILEV-1),NZ(ILEV-1),EPSZ(IDXM))
! c      CALL RESIDUALX(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,
! c     &               RHSX,RES,ERRORX)
! c      CALL RESIDUALY(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,
! c     &               RHSY,RES,ERRORY)
! c      CALL RESIDUALZ(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,
! c     &               RHSZ,RES,ERRORZ)
! c      ERROR=SQRT((ERRORX**2+ERRORY**2+ERRORZ**2)/3)
! c      WRITE(NOUT,*) 'A - LEVEL ',ILEV,' ERROR =',ERRORX,ERRORY,ERRORZ
      CALL RELAX(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,&
                          RHSX,RHSY,RHSZ)
        WORK=WORK+2.**(3*(ILEV-NLEV))
      CALL RESIDUALX(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,&
                    RHSX,RES,ERRORX)
      CALL RESIDUALY(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,&
                    RHSY,RES,ERRORY)
      CALL RESIDUALZ(NX(NLEV),NY(NLEV),NZ(NLEV),AX,AY,AZ,&
                   RHSZ,RES,ERRORZ)
      ERROR=SQRT((ERRORX**2+ERRORY**2+ERRORZ**2)/3)
! !      WRITE(NOUT,*) 'A - LEVEL ',ILEV,' ERROR =',ERRORX,ERRORY,ERRORZ
! c
! !      WRITE(NOUT,*) '     '
! !      WRITE(NOUT,*) 'Results on Top Level'
! !      WRITE(NOUT,*) '     '
! !      WRITE(NOUT,*) 'Work(!)   ',WORK,' Error(!)   ',ERROR
! !      WRITE(NOUT,*) '     '
! c
! c      WRITE(6,*) '     '
! c      WRITE(6,*) 'Results on Top Level'
! c      WRITE(6,*) '     '
! c      WRITE(6,*) 'Work(!)   ',WORK,' Error(!)   ',ERROR
! !       WRITE(3,*) WORK,ERROR
! !       call flush(3)
! c      WRITE(6,*) '     '
! c
! c      IF(ERROR.LE.DELTA) GOTO 13
! c
! c      IF(ERROR.GT.DELTA) THEN
! c        IF(WORK.LT.WMAX) GOTO 10
! c      ENDIF
! c        IF(WORK.GE.WMAX) THEN
! c          WRITE(NOUT,*) 'SLOW TO CONVERGE WORK=', WORK
! c        ENDIF
! c
! c------------------ITS loop
! c
       ! ITS = ITS + 1
! c
! 
! !        WRITE(NOUT,*) '    '
! !        WRITE(NOUT,*) 'completed ITS loop     ',ITS
! !        WRITE(NOUT,*) '    '
! c       WRITE(6,*) '    '
! c       WRITE(6,*) 'completed ITS loop     ',ITS
! c       WRITE(6,*) '    '
! c
! c      ENDDO
! c
        IF(ERROR.GT.DELTA) THEN
        IF(WORK.LT.WMAX)THEN
        GOTO 10
        ELSE
!        WRITE(NOUT,*) 'SLOW TO CONVERGE WORK=', WORK
        GOTO 13
        ENDIF
        ENDIF
! c
! c
  13   CONTINUE
! c
! c------------------------------------------------------------------
! C
! C WRITE RESULTS TO FILES IF APPROPRIATE
! C
         IF(ERROR.LE.DELTA) THEN
! !      WRITE(NOUT,*) 'Dumping Data Now'
! *       OPEN(UNIT=2,FILE='AX.OUTPT',FORM='UNFORMATTED',STATUS='UNKNOWN')
! *       WRITE(2) (AX(I),I=1,NPOINTS(NLEV))
! *       CLOSE(2)
! *       OPEN(UNIT=2,FILE='AY.OUTPT',FORM='UNFORMATTED',STATUS='UNKNOWN')
! *       WRITE(2) (AY(I),I=1,NPOINTS(NLEV))
! *       CLOSE(2)
! *       OPEN(UNIT=2,FILE='AZ.OUTPT',FORM='UNFORMATTED',STATUS='UNKNOWN')
! *       WRITE(2) (AZ(I),I=1,NPOINTS(NLEV))
! *       CLOSE(2)
        ENDIF
! C
! C SOURCE TO BE TIMED
! C
! !        WRITE(NOUT,*) ' THIS TOOK ', DTIME(TIMEAR),' SECONDS OF CPU'
! c
! !        CLOSE(NOUT)
! !        CLOSE(3)
! c

      
      deallocate(RHSX,RHSY,RHSZ)
     deallocate( EPSX,EPSRHSX)
     deallocate(  EPSY,EPSRHSY)
     deallocate(  EPSZ,EPSRHSZ)
     deallocate(  RES)
     deallocate(  EPSRES)

      return
      END
! c
! c------------------------------------------------------------------
! c


! *
! ** Now uses more accurate one sided derivatives
! *
      subroutine ATOB
      use duncan
      use cdata
        integer nmax
      !include 'sysdat1.dat'
      !PARAMETER (NMAX=2*na+1)
      !DOUBLE PRECISION AX(NMAX**3),AY(NMAX**3),AZ(NMAX**3),B(NMAX**3)
      !  double precision h0,alpha
      !  double precision om
     ! real bb(nx0**3)
     !   integer nx,ny,nz
     ! common/duncan/AX,AY,AZ
! c
      !OPEN (UNIT=1,FILE='CDATA.IN',FORM='FORMATTED')
      !READ(1,*) NX,OM, H0,DELTA,NLEV,WMAX,MAXITS,ISTART,ALPHA
      !CLOSE(1)
! *      print *,alpha
      nx=nx0
      ny = nx
      nz = nx
     ! CALL PROCESS(NX,NY,NZ,H0,AX,AY,AZ,B,bb,alpha)
     
     
     call writeout_whole2(ax,ay,az)
     deallocate(ax,ay,az)
      END
! *
! *
! *

      SUBROUTINE RELAX(NX,NY,NZ,AX,AY,AZ,RHSX,RHSY,RHSZ)
      use cdata
      IMPLICIT NONE
      INTEGER NX,NY,NZ
      DOUBLE PRECISION AX(NX,NY,NZ),AY(NX,NY,NZ),AZ(NX,NY,NZ),&
       RHSX(NX,NY,NZ),RHSY(NX,NY,NZ),RHSZ(NX,NY,NZ)
      !DOUBLE PRECISION ALPHA,H0,OM,
      double precision :: AM1OM
      !INTEGER NX0
     ! COMMON/CONST/ ALPHA,H0,NX0
     !   COMMON/SORE/ OM
      INTEGER I,J,K
      DOUBLE PRECISION H,ALPHAH,CROSSX,CROSSY,CROSSZ
! C
! C IMPLEMENT RELAXATION SCHEME HERE
! C
      H=H0*(NX0-1)/(NX-1)
      ALPHAH=ALPHA*H/2
        AM1OM = 1.0 - OM
! c
      DO K=2,NZ-1
        DO J=2,NY-1
          I=1
          CROSSX=(AZ(I,J+1,K)-AZ(I,J-1,K))-(AY(I,J,K+1)-AY(I,J,K-1))
          AX(I,J,K)=AM1OM*AX(I,J,K) + OM*(2.*AX(I+1,J,K)+AX(I,J-1,K)+&
           AX(I,J+1,K)+AX(I,J,K-1)+AX(I,J,K+1)+&
           ALPHAH*CROSSX-RHSX(I,J,K))/6.
          DO I=2,NX-1
            CROSSX=(AZ(I,J+1,K)-AZ(I,J-1,K))-(AY(I,J,K+1)-AY(I,J,K-1))
            AX(I,J,K)=AM1OM*AX(I,J,K) +&
            OM*(AX(I-1,J,K)+AX(I+1,J,K)+AX(I,J-1,K)+&
             AX(I,J+1,K)+AX(I,J,K-1)+AX(I,J,K+1)+&
             ALPHAH*CROSSX-RHSX(I,J,K))/6.
          ENDDO
          I=NX
          CROSSX=(AZ(I,J+1,K)-AZ(I,J-1,K))-(AY(I,J,K+1)-AY(I,J,K-1))
          AX(I,J,K)=AM1OM*AX(I,J,K) + OM*(2.*AX(I-1,J,K)+AX(I,J-1,K)+&
           AX(I,J+1,K)+AX(I,J,K-1)+AX(I,J,K+1)+&
           ALPHAH*CROSSX-RHSX(I,J,K))/6.
        ENDDO
      ENDDO
      DO K=2,NZ-1
        J=1
        DO I=2,NX-1
          CROSSY=(AX(I,J,K+1)-AX(I,J,K-1))-(AZ(I+1,J,K)-AZ(I-1,J,K))
          AY(I,J,K)=AM1OM*AY(I,J,K) + OM*(AY(I-1,J,K)+AY(I+1,J,K)+&
           2.*AY(I,J+1,K)+AY(I,J,K-1)+AY(I,J,K+1)+&
           ALPHAH*CROSSY-RHSY(I,J,K))/6.
        ENDDO
        DO J=2,NY-1
          DO I=2,NX-1
            CROSSY=(AX(I,J,K+1)-AX(I,J,K-1))-(AZ(I+1,J,K)-AZ(I-1,J,K))
            AY(I,J,K)=AM1OM*AY(I,J,K) +&
             OM*(AY(I-1,J,K)+AY(I+1,J,K)+AY(I,J-1,K)+&
             AY(I,J+1,K)+AY(I,J,K-1)+AY(I,J,K+1)+&
             ALPHAH*CROSSY-RHSY(I,J,K))/6.
          ENDDO
        ENDDO

        J=NY
        DO I=2,NX-1
          CROSSY=(AX(I,J,K+1)-AX(I,J,K-1))-(AZ(I+1,J,K)-AZ(I-1,J,K))
          AY(I,J,K)=AM1OM*AY(I,J,K) +&
           OM*(AY(I-1,J,K)+AY(I+1,J,K)+2.*AY(I,J-1,K)+&
           AY(I,J,K-1)+AY(I,J,K+1)+&
           ALPHAH*CROSSY-RHSY(I,J,K))/6.
        ENDDO
      ENDDO

      K=1
      DO J=2,NY-1
        DO I=2,NX-1
          CROSSZ=(AY(I+1,J,K)-AY(I-1,J,K))-(AX(I,J+1,K)-AX(I,J-1,K))
          AZ(I,J,K)=AM1OM*AZ(I,J,K) +&
           OM*(AZ(I-1,J,K)+AZ(I+1,J,K)+AZ(I,J-1,K)+&
           AZ(I,J+1,K)+2.*AZ(I,J,K+1)+&
           ALPHAH*CROSSZ-RHSZ(I,J,K))/6.
        ENDDO
      ENDDO
      DO K=2,NZ-1
        DO J=2,NY-1
          DO I=2,NX-1
            CROSSZ=(AY(I+1,J,K)-AY(I-1,J,K))-(AX(I,J+1,K)-AX(I,J-1,K))
            AZ(I,J,K)=AM1OM*AZ(I,J,K) +&
             OM*(AZ(I-1,J,K)+AZ(I+1,J,K)+AZ(I,J-1,K)+&
             AZ(I,J+1,K)+AZ(I,J,K-1)+AZ(I,J,K+1)+&
             ALPHAH*CROSSZ-RHSZ(I,J,K))/6.
          ENDDO
        ENDDO
      ENDDO
      K=NZ
      DO J=2,NY-1
        DO I=2,NX-1
          CROSSZ=(AY(I+1,J,K)-AY(I-1,J,K))-(AX(I,J+1,K)-AX(I,J-1,K))
          AZ(I,J,K)=AM1OM*AZ(I,J,K) +&
           OM*(AZ(I-1,J,K)+AZ(I+1,J,K)+AZ(I,J-1,K)+&
           AZ(I,J+1,K)+2.*AZ(I,J,K-1)+&
           ALPHAH*CROSSZ-RHSZ(I,J,K))/6.
        ENDDO
      ENDDO
      END

      SUBROUTINE RESIDUALX(NX,NY,NZ,AX,AY,AZ,RHS,RES,ERROR)
      use cdata
      IMPLICIT NONE
      INTEGER NX,NY,NZ
      DOUBLE PRECISION AX(NX,NY,NZ),AY(NX,NY,NZ),&
       AZ(NX,NY,NZ),RHS(NX,NY,NZ),RES(NX,NY,NZ)
      DOUBLE PRECISION ERROR
      !DOUBLE PRECISION ALPHA,H0
      !INTEGER NX0
     ! COMMON/CONST/ ALPHA,H0,NX0
      INTEGER I,J,K,IM,IP
      DOUBLE PRECISION ALPHAH,H,R,CROSS
! C23456789012345678901234567890123456789012345678901234567890123456789012
! C
! C CALCULATE RESIDUALS HERE
! C
      ERROR=0.0
      H=H0*(NX0-1)/(NX-1)
      ALPHAH=ALPHA*H/2
      DO K=2,NZ-1
        DO J=2,NY-1
          DO I=1,NX
            IM=MAX(I,2)-MIN(I,2)+1
            IP=MIN(I,NX-1)-MAX(I,NX-1)+NX
            CROSS=AZ(I,J+1,K)-AZ(I,J-1,K)-(AY(I,J,K+1)-AY(I,J,K-1))
            R=AX(IM,J,K)+AX(IP,J,K)+AX(I,J-1,K)+&
             AX(I,J+1,K)+AX(I,J,K-1)+AX(I,J,K+1)-6.*AX(I,J,K)+&
             ALPHAH*CROSS
            RES(I,J,K)=(RHS(I,J,K)-R)
            ERROR=ERROR+RES(I,J,K)**2
          ENDDO
        ENDDO
      ENDDO
      ERROR=SQRT(ERROR*NX)
      END

      SUBROUTINE RESIDUALY(NX,NY,NZ,AX,AY,AZ,RHS,RES,ERROR)
      use cdata
      IMPLICIT NONE
      INTEGER NX,NY,NZ
      DOUBLE PRECISION AX(NX,NY,NZ),AY(NX,NY,NZ),&
       AZ(NX,NY,NZ),RHS(NX,NY,NZ),RES(NX,NY,NZ)
      DOUBLE PRECISION ERROR
      !DOUBLE PRECISION ALPHA,H0
      !INTEGER NX0
      !COMMON/CONST/ ALPHA,H0,NX0
      INTEGER I,J,K,JM,JP
      DOUBLE PRECISION ALPHAH,H,R,CROSS
! C23456789012345678901234567890123456789012345678901234567890123456789012
! C
! C CALCULATE RESIDUALS HERE
! C
      ERROR=0.0
      H=H0*(NX0-1)/(NX-1)
      ALPHAH=ALPHA*H/2
      DO K=2,NZ-1
        DO J=1,NY
          JM=MAX(J,2)-MIN(2,J)+1
          JP=MIN(J,NY-1)-MAX(J,NY-1)+NY
          DO I=2,NX-1
            CROSS=AX(I,J,K+1)-AX(I,J,K-1)-(AZ(I+1,J,K)-AZ(I-1,J,K))
            R=AY(I-1,J,K)+AY(I+1,J,K)+AY(I,JM,K)+&
             AY(I,JP,K)+AY(I,J,K-1)+AY(I,J,K+1)-6.*AY(I,J,K)+&
             ALPHAH*CROSS
            RES(I,J,K)=(RHS(I,J,K)-R)
            ERROR=ERROR+RES(I,J,K)**2
          ENDDO
        ENDDO
      ENDDO
      ERROR=SQRT(ERROR*NX)
      END

      SUBROUTINE RESIDUALZ(NX,NY,NZ,AX,AY,AZ,RHS,RES,ERROR)
      use cdata
      IMPLICIT NONE
      INTEGER NX,NY,NZ
      DOUBLE PRECISION AX(NX,NY,NZ),AY(NX,NY,NZ),&
       AZ(NX,NY,NZ),RHS(NX,NY,NZ),RES(NX,NY,NZ)
      DOUBLE PRECISION ERROR
     ! DOUBLE PRECISION ALPHA,H0
     ! INTEGER NX0
     ! COMMON/CONST/ ALPHA,H0,NX0
      INTEGER I,J,K,KM,KP
      DOUBLE PRECISION ALPHAH,H,R,CROSS
! C23456789012345678901234567890123456789012345678901234567890123456789012
! C
! C CALCULATE RESIDUALS HERE
! C
      ERROR=0.0
      H=H0*(NX0-1)/(NX-1)
      ALPHAH=ALPHA*H/2
      DO K=1,NZ
        KM=MAX(K,2)-MIN(K,2)+1
        KP=MIN(K,NZ-1)-MAX(K,NZ-1)+NZ
        DO J=2,NY-1
          DO I=2,NX-1
            CROSS=AY(I+1,J,K)-AY(I-1,J,K)-(AX(I,J+1,K)-AX(I,J-1,K))
            R=AZ(I-1,J,K)+AZ(I+1,J,K)+AZ(I,J-1,K)+&
             AZ(I,J+1,K)+AZ(I,J,KM)+AZ(I,J,KP)-6.*AZ(I,J,K)+&
             ALPHAH*CROSS
            RES(I,J,K)=(RHS(I,J,K)-R)
            ERROR=ERROR+RES(I,J,K)**2
          ENDDO
        ENDDO
      ENDDO
      ERROR=SQRT(ERROR*NX)
      END


      SUBROUTINE RESTRICTC(NXF,NYF,NZF,FINE,NXC,NYC,NZC,COARSE)
      IMPLICIT NONE
      INTEGER NXF,NYF,NZF,NXC,NYC,NZC
      DOUBLE PRECISION FINE(NXF,NYF,NZF),COARSE(NXC,NYC,NZC)
      INTEGER IXF,JYF,KZF,IXC,JYC,KZC,IP,IM,JP,JM,KP,KM
      DOUBLE PRECISION VALM,VAL0,VALP,WEIGHT1
! C
! C INJECTION FOR RESTRICTION ON INTERIOR
! C
! C AT FIRST ASSUME FULL COARSENING
! C

      DO KZC=1,NZC
        KZF=2*KZC-1
        KM=MAX(KZF,2)-MIN(KZF,2)+1
        KP=MIN(KZF,NZF-1)-MAX(KZF,NZF-1)+NZF
        DO JYC=1,NYC
          JYF=2*JYC-1
          JM=MAX(JYF,2)-MIN(JYF,2)+1
          JP=MIN(JYF,NYF-1)-MAX(JYF,NYF-1)+NYF
          IP=2
          VALP=WEIGHT1(IP,JM,JYF,JP,KM,KZF,KP,NXF,NYF,NZF,FINE)
          DO IXC=1,NXC
            IXF=2*IXC-1
            IM=MAX(IXF,2)-MIN(IXF,2)+1
            IP=MIN(IXF,NXF-1)-MAX(IXF,NXF-1)+NXF
            VALM=VALP
            VAL0=WEIGHT1(IXF,JM,JYF,JP,KM,KZF,KP,NXF,NYF,NZF,FINE)
            VALP=WEIGHT1(IP,JM,JYF,JP,KM,KZF,KP,NXF,NYF,NZF,FINE)
            COARSE(IXC,JYC,KZC)=(VALM+2*VAL0+VALP)/16.
! c            COARSE(IXC,JYC,KZC)=FINE(IXF,JYF,KZF)*4.
          ENDDO
        ENDDO
      ENDDO
      END



      DOUBLE PRECISION FUNCTION WEIGHT1(I,JM,J,JP,KM,K,KP,NX,NY,NZ,A)
      IMPLICIT NONE
      INTEGER I,JM,J,JP,KM,K,KP,NX,NY,NZ
      DOUBLE PRECISION A(NX,NY,NZ)
      WEIGHT1=A(I,JM,KM)+A(I,JM,KP)+A(I,JP,KM)+A(I,JP,KP)&
       +2*(A(I,J,KM)+A(I,J,KP)+A(I,JM,K)+A(I,JP,K))&
       +4*A(I,J,K)
      END


      SUBROUTINE INTADD(NXF,NYF,NZF,FINE,NXC,NYC,NZC,COARSE)
      IMPLICIT NONE
      INTEGER NXF,NYF,NZF,NXC,NYC,NZC
      DOUBLE PRECISION COARSE(NXC,NYC,NZC),FINE(NXF,NYF,NZF)
      INTEGER IXC,IXF,JYC,JYF,KZC,KZF
! c
! c Interior points first
! c
      DO KZC=1,NZC
        KZF=2*KZC-1
        DO JYC=1,NYC
          JYF=2*JYC-1
          DO IXC=1,NXC
            IXF=2*IXC-1
            FINE(IXF,JYF,KZF)=FINE(IXF,JYF,KZF)+COARSE(IXC,JYC,KZC)
          ENDDO
        ENDDO
      ENDDO

! c
! c i+1/2
! c
      DO KZC=1,NZC
        KZF=2*KZC-1
        DO JYC=1,NYC
          JYF=2*JYC-1
          DO IXC=1,NXC-1
            IXF=2*IXC-1
            FINE(IXF+1,JYF,KZF)=FINE(IXF+1,JYF,KZF)+&
             (COARSE(IXC,JYC,KZC)+COARSE(IXC+1,JYC,KZC))/2.
          ENDDO
        ENDDO
      ENDDO
! c
! c j+1/2
! c
      DO KZC=1,NZC
        KZF=2*KZC-1
        DO JYC=1,NYC-1
          JYF=2*JYC-1
          DO IXC=1,NXC
            IXF=2*IXC-1
            FINE(IXF,JYF+1,KZF)=FINE(IXF,JYF+1,KZF)+&
             (COARSE(IXC,JYC,KZC)+COARSE(IXC,JYC+1,KZC))/2.
          ENDDO
        ENDDO
      ENDDO
! c
! c k+1/2
! c
      DO KZC=1,NZC-1
        KZF=2*KZC-1
        DO JYC=1,NYC
          JYF=2*JYC-1
          DO IXC=1,NXC
            IXF=2*IXC-1
            FINE(IXF,JYF,KZF+1)=FINE(IXF,JYF,KZF+1)+&
             (COARSE(IXC,JYC,KZC)+COARSE(IXC,JYC,KZC+1))/2.
          ENDDO
        ENDDO
      ENDDO
! c
! c i+1/2,j+1/2
! c
      DO KZC=1,NZC
        KZF=2*KZC-1
        DO JYC=1,NYC-1
          JYF=2*JYC-1
          DO IXC=1,NXC-1
            IXF=2*IXC-1
            FINE(IXF+1,JYF+1,KZF)=FINE(IXF+1,JYF+1,KZF)+&
             (COARSE(IXC,JYC,KZC)+COARSE(IXC+1,JYC+1,KZC)+&
              COARSE(IXC+1,JYC,KZC)+COARSE(IXC,JYC+1,KZC))/4.
          ENDDO
        ENDDO
      ENDDO


! c i+1/2,k+1/2
! c
      DO KZC=1,NZC-1
        KZF=2*KZC-1
        DO JYC=1,NYC
          JYF=2*JYC-1
          DO IXC=1,NXC-1
            IXF=2*IXC-1
            FINE(IXF+1,JYF,KZF+1)=FINE(IXF+1,JYF,KZF+1)+&
             (COARSE(IXC,JYC,KZC)+COARSE(IXC+1,JYC,KZC+1)+&
              COARSE(IXC+1,JYC,KZC)+COARSE(IXC,JYC,KZC+1))/4.
          ENDDO
        ENDDO
      ENDDO
! c
! c j+1/2,k+1/2
! c
      DO KZC=1,NZC-1
        KZF=2*KZC-1
        DO JYC=1,NYC-1
          JYF=2*JYC-1
          DO IXC=1,NXC
            IXF=2*IXC-1
            FINE(IXF,JYF+1,KZF+1)=FINE(IXF,JYF+1,KZF+1)+&
             (COARSE(IXC,JYC,KZC)+COARSE(IXC,JYC+1,KZC+1)+&
              COARSE(IXC,JYC+1,KZC)+COARSE(IXC,JYC,KZC+1))/4.
          ENDDO
        ENDDO
      ENDDO
! c
! c i+1/2,j+1/2,k+1/2
! c
      DO KZC=1,NZC-1
        KZF=2*KZC-1
        DO JYC=1,NYC-1
          JYF=2*JYC-1
          DO IXC=1,NXC-1
            IXF=2*IXC-1
            FINE(IXF+1,JYF+1,KZF+1)=FINE(IXF+1,JYF+1,KZF+1)+&
             (COARSE(IXC,JYC,KZC)+COARSE(IXC+1,JYC,KZC)+&
              COARSE(IXC,JYC+1,KZC)+COARSE(IXC,JYC,KZC+1)+&
              COARSE(IXC+1,JYC+1,KZC)+COARSE(IXC+1,JYC,KZC+1)+&
              COARSE(IXC,JYC+1,KZC+1)+COARSE(IXC+1,JYC+1,KZC+1))/8.
          ENDDO
        ENDDO
      ENDDO
      END


      DOUBLE PRECISION FUNCTION AXSET(X,Y,Z)
      IMPLICIT NONE
      DOUBLE PRECISION X,Y,Z
      AXSET=0.
      END


      DOUBLE PRECISION FUNCTION AYSET(X,Y,Z)
      IMPLICIT NONE
      DOUBLE PRECISION X,Y,Z
      AYSET=0.
      END

      DOUBLE PRECISION FUNCTION AZSET(X,Y,Z)
      IMPLICIT NONE
      DOUBLE PRECISION X,Y,Z
      AZSET=0.
      END

!       SUBROUTINE BOUNDY(NX,NY,NZ,H,A,F)
!       IMPLICIT NONE
!       EXTERNAL F
!       INTEGER NX,NY,NZ
!       DOUBLE PRECISION H,A(NX,NY,NZ),F
!       DOUBLE PRECISION X,Y,Z
!       INTEGER I,J,K
!       K=1
!       Z=0.0D0
!       DO J=1,NY
!         Y=(J-1)*H
!         DO I=1,NX
!           X=(I-1)*H
!           A(I,J,K)=F(X,Y,Z)
!         ENDDO
!       ENDDO
!       DO K=2,NZ-1
!         Z=(K-1)*H
!         J=1
!         Y=0.0D0
!         DO I=1,NX
!           X=(I-1)*H
!           A(I,J,K)=F(X,Y,Z)
!         ENDDO
!         DO J=2,NY-1
!           Y=(J-1)*H
!           I=1
!           X=0.0D0
!           A(I,J,K)=F(X,Y,Z)
!           I=NX
!           X=1.0D0
!           A(I,J,K)=F(X,Y,Z)
!         ENDDO
!         J=NY
!         Y=1.0D0
!         DO I=1,NX
!           X=(I-1)*H
!           A(I,J,K)=F(X,Y,Z)
!         ENDDO
!       ENDDO
!       K=NZ
!       Z=1.0D0
!       DO J=1,NY
!         Y=(J-1)*H
!         DO I=1,NX
!           X=(I-1)*H
!           A(I,J,K)=F(X,Y,Z)
!         ENDDO
!       ENDDO
!       END

      SUBROUTINE INITIALISE(NX,NY,NZ,H,A,F)
      IMPLICIT NONE
      EXTERNAL F
      INTEGER NX,NY,NZ
      DOUBLE PRECISION H,A(NX,NY,NZ),F
      DOUBLE PRECISION X,Y,Z
      INTEGER I,J,K
      DO K=1,NZ
        Z=(K-1)*H
        DO J=1,NY
          Y=(J-1)*H
          DO I=1,NX
             X=(I-1)*H
             A(I,J,K)=F(X,Y,Z)
          ENDDO
        ENDDO
      ENDDO
      END


 
!       SUBROUTINE READA(N,AX,AY,AZ)
!       DOUBLE PRECISION AX(N),AY(N),AZ(N)
! *       print *,n
!       OPEN(UNIT=8,FILE='AX.OUTPT',FORM='UNFORMATTED')
! *      print *,' reading Ax'
!       READ(8) (AX(I),I=1,N)
! c     READ(8) AX
!       CLOSE(8)
!       OPEN(UNIT=3,FILE='AY.OUTPT',FORM='UNFORMATTED')
! *      print *,' reading Ay'
!       READ(3) (AY(I),I=1,N)
! c     READ(3) AY
!       CLOSE(3)
!       OPEN(UNIT=4,FILE='AZ.OUTPT',FORM='UNFORMATTED')
! *      print *,' reading Az'
!       READ(4) (AZ(I),I=1,N)
! c     READ(4) AZ
!       CLOSE(4)
!       END
! C

!       SUBROUTINE PROCESS(NX,NY,NZ,H,AX,AY,AZ,B,bb,alpha)
! c
! c       Here convert the A's back into B's.
! c       Simple one-sided derivatives at the boundaries.
! c       Note that all derivatives are multiplied by 2*h,
! c       where h is the grid spacing. Thus the basic
! c       central derivative is just A(i+1)-A(i-1), for example.
! c       Can account for the 2*h factor in any IDL routines.
! c
!       DOUBLE PRECISION AX(NX,NY,NZ),AY(NX,NY,NZ),
!      &  AZ(NX,NY,NZ),B(NX,NY,NZ)
!         double precision diva,h,alpha,divab,tdel
!         double precision helicx,helicy,helicz,helic
!         double precision b2x,b2y,b2z,b2
!         real             bb(nx,ny,nz)
!         integer nx,ny,nz,npoints
! c
!        npoints=nx*ny*nz
! c      CALL READA(npoints,AX,AY,AZ)
! 
!       print*,nx,ny,nz
!       OPEN(UNIT=10,FILE='AXOUT',FORM='UNFORMATTED')
!       WRITE(10) Ax
!       CLOSE(10)
!       OPEN(UNIT=10,FILE='AYOUT',FORM='UNFORMATTED')
!       WRITE(10) Ay
!       CLOSE(10)
!       OPEN(UNIT=10,FILE='AZOUT',FORM='UNFORMATTED')
!       WRITE(10) Az
!       CLOSE(10)
! 
! 
!       stop
! 
! c----------------- check div(A) across the domain
! c----------------- assume normal derivs across the
! c----------------- boundaries are zero for normal
! c----------------- component of A. Account explicitly
! c----------------- for 2*h factor here.
! c
!         divab = 0.d0
!         tdel = 1.d0/(2.d0*h)
! c------------------------- edges
! c
!         do j=1,ny,ny-1
!         do i=1,nx,nx-1
!         do k=2,nz-1
!         diva = az(i,j,k+1)-az(i,j,k-1)
!         divab=dmax1(divab,dabs(tdel*diva))
!         enddo
!         enddo
!         enddo
! c
!         do j=1,ny,ny-1
!         do k=1,nz,nz-1
!         do i=2,nx-1
!         diva = ax(i+1,j,k)-ax(i-1,j,k)
!         divab=dmax1(divab,dabs(tdel*diva))
!         enddo
!         enddo
!         enddo
! c
!         do i=1,nx,nx-1
!         do k=1,nz,nz-1
!         do j=2,ny-1
!         diva = ay(i,j+1,k)-ay(i,j-1,k)
!         divab=dmax1(divab,dabs(tdel*diva))
!         enddo
!         enddo
!         enddo
! 
! c
! c------------------------- faces
!         do k=1,nz,nz-1
!         do j=2,ny-1
!         do i=2,nx-1
!         diva = ax(i+1,j,k)-ax(i-1,j,k) +
!      &         ay(i,j+1,k)-ay(i,j-1,k)
!         divab=dmax1(divab,dabs(tdel*diva))
!         enddo
!         enddo
!         enddo
! c
!         do j=1,ny,ny-1
!         do k=2,nz-1
!         do i=2,nx-1
!         diva = ax(i+1,j,k)-ax(i-1,j,k) +
!      &         az(i,j,k+1)-az(i,j,k-1)
!         divab=dmax1(divab,dabs(tdel*diva))
!         enddo
!         enddo
!         enddo
! c
!         do i=1,nx,nx-1
!         do k=2,nz-1
!         do j=2,ny-1
!         diva = ay(i,j+1,k)-ay(i,j-1,k) +
!      &         az(i,j,k+1)-az(i,j,k-1)
!         divab=dmax1(divab,dabs(tdel*diva))
!         enddo
!         enddo
!         enddo
! c------------------------- main grid
!         do k=2,nz-1
!         do j=2,ny-1
!         do i=2,nx-1
!         diva = ax(i+1,j,k)-ax(i-1,j,k) +
!      &         ay(i,j+1,k)-ay(i,j-1,k) +
!      &         az(i,j,k+1)-az(i,j,k-1)
!         divab=dmax1(divab,dabs(tdel*diva))
!         enddo
!         enddo
!         enddo
! c
! *        print *,'max diva is    ',divab
! c---------------------------------------------------------
! c
! C CALCULATE BX
! C
! C
! C Z=0
! C
! C12345678901234567890123456789012345678901234567890123456789012345678901
!       K=1
!       J=1
!       DO I=1,NX
!         B(I,J,K)=(4.*AZ(I,J+1,K)-AZ(I,J+2,K)-3.*AZ(I,J,K))
!      &          -(4.*AY(I,J,K+1)-AY(I,J,K+2)-3.*AY(I,J,K))
!       ENDDO
!       DO J=2,NY-1
!         DO I=1,NX
!           B(I,J,K)=(AZ(I,J+1,K)-AZ(I,J-1,K))
!      &            -(4.*AY(I,J,K+1)-AY(I,J,K+2)-3.*AY(I,J,K))
!         ENDDO
!       ENDDO
!       J=NY
!       DO I=1,NX
!         B(I,J,K)=-(4.*AZ(I,J-1,K)-AZ(I,J-2,K)-3.*AZ(I,J,K))
!      &           -(4.*AY(I,J,K+1)-AY(I,J,K+2)-3.*AY(I,J,K))
! 
!       ENDDO
!       DO K=2,NZ-1
!         J=1
!         DO I=1,NX
!           B(I,J,K)=(4.*AZ(I,J+1,K)-AZ(I,J+2,K)-3.*AZ(I,J,K))
!      &            -(AY(I,J,K+1)-AY(I,J,K-1))
!         ENDDO
!         DO J=2,NY-1
!           DO I=1,NX
!             B(I,J,K)=(AZ(I,J+1,K)-AZ(I,J-1,K))-(AY(I,J,K+1)-AY(I,J,K-1))
!           ENDDO
!         ENDDO
!         J=NY
!         DO I=1,NX
!           B(I,J,K)=-(4.*AZ(I,J-1,K)-AZ(I,J-2,K)-3.*AZ(I,J,K))
!      &             -(AY(I,J,K+1)-AY(I,J,K-1))
! 
!         ENDDO
!       ENDDO
!       K=NZ
!       J=1
!       DO I=1,NX
!         B(I,J,K)=(4.*AZ(I,J+1,K)-AZ(I,J+2,K)-3.*AZ(I,J,K))
!      &          +(4.*AY(I,J,K-1)-AY(I,J,K-2)-3.*AY(I,J,K))
!       ENDDO
!       DO J=2,NY-1
!         DO I=1,NX
!           B(I,J,K)=(AZ(I,J+1,K)-AZ(I,J-1,K))
!      &            +(4.*AY(I,J,K-1)-AY(I,J,K-2)-3.*AY(I,J,K))
!         ENDDO
!       ENDDO
!       J=NY
!       DO I=1,NX
!         B(I,J,K)=-(4.*AZ(I,J-1,K)-AZ(I,J-2,K)-3.*AZ(I,J,K))
!      &           +(4.*AY(I,J,K-1)-AY(I,J,K-2)-3.*AY(I,J,K))
!       ENDDO
! *      print *,' writing Bx'
!       OPEN(UNIT=2,FILE='BXOUT',FORM='UNFORMATTED')
!       WRITE(2) B
!       CLOSE(2)
! *
! c     open(unit=10,file='BOUT',form='unformatted')
! c     do i=1,nx
! c     do j=1,ny
! c     do k=1,nz
! c        bb(i,j,k) = float(b(i,j,k))
! c     enddo
! c     enddo
! c     enddo
! c     write(10) bb
! c
! c Calculate energy and helicity
! c
!         b2 = 0.d0
!         helic = 0.d0
! c
!         b2x = 0.d0
!         helicx = 0.d0
! *
!       do k=1,nz-1
!         do j=1,ny-1
!           do i=1,nx-1
!             b2x=b2x+(b(i,j,k)*b(i,j,k)+b(i+1,j,k)*b(i+1,j,k)+
!      &        b(i,j+1,k)*b(i,j+1,k)+b(i,j,k+1)*b(i,j,k+1)+
!      &        b(i+1,j+1,k)*b(i+1,j+1,k)+b(i+1,j,k+1)*b(i+1,j,k+1)+
!      &        b(i,j+1,k+1)*b(i,j+1,k+1)+b(i+1,j+1,k+1)*b(i+1,j+1,k+1))
!             helicx=helicx+(b(i,j,k)*ax(i,j,k)+b(i+1,j,k)*ax(i+1,j,k)+
!      &        b(i,j+1,k)*ax(i,j+1,k)+b(i,j,k+1)*ax(i,j,k+1)+
!      &        b(i+1,j+1,k)*ax(i+1,j+1,k)+b(i+1,j,k+1)*ax(i+1,j,k+1)+
!      &        b(i,j+1,k+1)*ax(i,j+1,k+1)+b(i+1,j+1,k+1)*ax(i+1,j+1,k+1))
!            enddo
!          enddo
!       enddo
! C
! C NOW BY
! C
! C Z=0
! C
!       K=1
!       DO J=1,NY
!         I=1
!         B(I,J,K)=(4.d0*AX(I,J,K+1)-AX(I,J,K+2)-3.d0*AX(I,J,K))
!      &          -(4.d0*AZ(I+1,J,K)-AZ(I+2,J,K)-3.d0*AZ(I,J,K))
!         DO I=2,NX-1
!           B(I,J,K)=(4.d0*AX(I,J,K+1)-AX(I,J,K+2)-3.d0*AX(I,J,K))
!      &            -(AZ(I+1,J,K)-AZ(I-1,J,K))
!         ENDDO
!         I=NX
!         B(I,J,K)=(4.d0*AX(I,J,K+1)-AX(I,J,K+2)-3.d0*AX(I,J,K))
!      &          +(4.d0*AZ(I-1,J,K)-AZ(I-2,J,K)-3.d0*AZ(I,J,K))
!       ENDDO
!       DO K=2,NZ-1
!         DO J=1,NY
!           I=1
!           B(I,J,K)=(AX(I,J,K+1)-AX(I,J,K-1))
!      &          -(4.d0*AZ(I+1,J,K)-AZ(I+2,J,K)-3.d0*AZ(I,J,K))
!           DO I=2,NX-1
!             B(I,J,K)=(AX(I,J,K+1)-AX(I,J,K-1))-(AZ(I+1,J,K)-AZ(I-1,J,K))
!           ENDDO
!           I=NX
!           B(I,J,K)=(AX(I,J,K+1)-AX(I,J,K-1))
!      &          +(4.d0*AZ(I-1,J,K)-AZ(I-2,J,K)-3.d0*AZ(I,J,K))
!         ENDDO
!       ENDDO
!       K=NZ
!       DO J=1,NY
!         I=1
!         B(I,J,K)=-(4.d0*AX(I,J,K-1)-AX(I,J,K-2)-3.d0*AX(I,J,K))
!      &           -(4.d0*AZ(I+1,J,K)-AZ(I+2,J,K)-3.d0*AZ(I,J,K))
!         DO I=2,NX-1
!           B(I,J,K)=-(4.d0*AX(I,J,K-1)-AX(I,J,K-2)-3.d0*AX(I,J,K))
!      &             -(AZ(I+1,J,K)-AZ(I-1,J,K))
!         ENDDO
!         I=NX
!         B(I,J,K)=-(4.d0*AX(I,J,K-1)-AX(I,J,K-2)-3.d0*AX(I,J,K))
!      &           +(4.d0*AZ(I-1,J,K)-AZ(I-2,J,K)-3.d0*AZ(I,J,K))
!       ENDDO
!       WRITE(*,*) ' writing By'
!       OPEN(UNIT=2,FILE='BYOUT',FORM='UNFORMATTED')
!       WRITE(2) B
!       CLOSE(2)
! *
! c     do i=1,nx
! c     do j=1,ny
! c     do k=1,nz
! c        bb(i,j,k) = float(b(i,j,k))
! c     enddo
! c     enddo
! c     enddo
! c     write(10) bb
! c
! c Calculate energy and helicity
! c
!         b2y = 0.d0
!         helicy = 0.d0
! c
!       do k=1,nz-1
!         do j=1,ny-1
!           do i=1,nx-1
!             b2y=b2y+(b(i,j,k)*b(i,j,k)+b(i+1,j,k)*b(i+1,j,k)+
!      &        b(i,j+1,k)*b(i,j+1,k)+b(i,j,k+1)*b(i,j,k+1)+
!      &        b(i+1,j+1,k)*b(i+1,j+1,k)+b(i+1,j,k+1)*b(i+1,j,k+1)+
!      &        b(i,j+1,k+1)*b(i,j+1,k+1)+b(i+1,j+1,k+1)*b(i+1,j+1,k+1))
!             helicy=helicy+(b(i,j,k)*ay(i,j,k)+b(i+1,j,k)*ay(i+1,j,k)+
!      &        b(i,j+1,k)*ay(i,j+1,k)+b(i,j,k+1)*ay(i,j,k+1)+
!      &        b(i+1,j+1,k)*ay(i+1,j+1,k)+b(i+1,j,k+1)*ay(i+1,j,k+1)+
!      &        b(i,j+1,k+1)*ay(i,j+1,k+1)+b(i+1,j+1,k+1)*ay(i+1,j+1,k+1))
!            enddo
!          enddo
!       enddo
! C
! C Z=0
! C
!       DO K=1,NZ
!         J=1
!         I=1
!         B(I,J,K)=(4.d0*AY(I+1,J,K)-AY(I+2,J,K)-3.d0*AY(I,J,K))
!      &          -(4.d0*AX(I,J+1,K)-AX(I,J+2,K)-3.d0*AX(I,J,K))
!         DO I=2,NX-1
!           B(I,J,K)=(AY(I+1,J,K)-AY(I-1,J,K))
!      &          -(4.d0*AX(I,J+1,K)-AX(I,J+2,K)-3.d0*AX(I,J,K))
!         ENDDO
!         I=NX
!         B(I,J,K)=-(4.d0*AY(I-1,J,K)-AY(I-2,J,K)-3.d0*AY(I,J,K))
!      &           -(4.d0*AX(I,J+1,K)-AX(I,J+2,K)-3.d0*AX(I,J,K))
!         DO J=2,NY-1
!           I=1
!           B(I,J,K)=(4.d0*AY(I+1,J,K)-AY(I+2,J,K)-3.d0*AY(I,J,K))
!      &            -(AX(I,J+1,K)-AX(I,J-1,K))
!           DO I=2,NX-1
!             B(I,J,K)=(AY(I+1,J,K)-AY(I-1,J,K))-(AX(I,J+1,K)-AX(I,J-1,K))
!           ENDDO
!           I=NX
!           B(I,J,K)=-(4.d0*AY(I-1,J,K)-AY(I-2,J,K)-3.d0*AY(I,J,K))
!      &            -(AX(I,J+1,K)-AX(I,J-1,K))
!         ENDDO
!         J=NY
!         I=1
!         B(I,J,K)=(4.d0*AY(I+1,J,K)-AY(I+2,J,K)-3.d0*AY(I,J,K))
!      &          +(4.d0*AX(I,J-1,K)-AX(I,J-2,K)-3.d0*AX(I,J,K))
!         DO I=2,NX-1
!           B(I,J,K)=(AY(I+1,J,K)-AY(I-1,J,K))
!      &          +(4.d0*AX(I,J-1,K)-AX(I,J-2,K)-3.d0*AX(I,J,K))
!         ENDDO
!         I=NX
!         B(I,J,K)=-(4.d0*AY(I-1,J,K)-AY(I-2,J,K)-3.d0*AY(I,J,K))
!      &          +(4.d0*AX(I,J-1,K)-AX(I,J-2,K)-3.d0*AX(I,J,K))
!         
!       ENDDO
!       WRITE(*,*) ' writing Bz'
!       OPEN(UNIT=2,FILE='BZOUT',FORM='UNFORMATTED')
!       WRITE(2) B
!       CLOSE(2)
! *
! c     do i=1,nx
! c     do j=1,ny
! c     do k=1,nz
! c        bb(i,j,k) = float(b(i,j,k))
! c     enddo
! c     enddo
! c     enddo
! c     write(10) bb
! c     close(10)
! c
! c Calculate energy and helicity
! c
!         b2z = 0.d0
!         helicz = 0.d0
! c
!       do k=1,nz-1
!         do j=1,ny-1
!           do i=1,nx-1
!             b2z=b2z+(b(i,j,k)*b(i,j,k)+b(i+1,j,k)*b(i+1,j,k)+
!      &        b(i,j+1,k)*b(i,j+1,k)+b(i,j,k+1)*b(i,j,k+1)+
!      &        b(i+1,j+1,k)*b(i+1,j+1,k)+b(i+1,j,k+1)*b(i+1,j,k+1)+
!      &        b(i,j+1,k+1)*b(i,j+1,k+1)+b(i+1,j+1,k+1)*b(i+1,j+1,k+1))
!             helicz=helicz+(b(i,j,k)*az(i,j,k)+b(i+1,j,k)*az(i+1,j,k)+
!      &        b(i,j+1,k)*az(i,j+1,k)+b(i,j,k+1)*az(i,j,k+1)+
!      &        b(i+1,j+1,k)*az(i+1,j+1,k)+b(i+1,j,k+1)*az(i+1,j,k+1)+
!      &        b(i,j+1,k+1)*az(i,j+1,k+1)+b(i+1,j+1,k+1)*az(i+1,j+1,k+1))
!            enddo
!          enddo
!       enddo
! c
!         helic = helicx + helicy + helicz
!         b2 = b2x + b2y + b2z
! c
!       write(*,*) 'alpha=',alpha
!         write(*,*) 'helicities ',helicx,helicy,helicz,helic
!         write(*,*) 'energies   ',b2x,b2y,b2z,b2
!       END



